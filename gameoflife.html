<html>
<body style="padding:0px;margin:0px"></body>
<script>
(function(){
	
	var w = document.body.offsetWidth,
		h = document.body.offsetHeight,
		size, nx, ny,
		setSize = function(s){
			size = s;
			nx = Math.ceil(w / size);
			ny = Math.ceil(h / size);
		},
		zoom = function(factor){
			var centerLocation = mousePositionToPositionLocation(w/2, h/2);
			var newSize;
			if(factor < 1){
				newSize = Math.max(1, Math.floor(size * factor));
			}else{
				newSize = size * factor;
			}
			setSize(newSize);
			xShift = Math.floor(w/(2 * size) - centerLocation.x);
			yShift = Math.floor(h/(2 * size) - centerLocation.y);
		},
		xShift = 0,
		yShift = 0,
		c = (function(){
			var canvas = document.createElement("canvas");
			canvas.setAttribute("width", w);
			canvas.setAttribute("height", h);
			document.body.appendChild(canvas);
			var context = canvas.getContext("2d");
			var initializeContext = function(){
				context.strokeStyle = '#000';
				context.lineWidth = 0.1;
				context.fillStyle = '#000';
			};
			initializeContext();
			canvas.addEventListener('click',function(e){
				var p = mousePositionToPosition(e.clientX, e.clientY);
				
				if(p.isOccupied()){
					p.vacate();
				}else{
					p.occupy();
				}
				drawAll();
			});
			return {
				context:context,
				clear:function(){canvas.width = w;initializeContext();}
			};
		})(),
		context = c.context,
		clear = c.clear,
		drawVerticalLine = function(x){
			context.beginPath();
			context.moveTo(x,0);
			context.lineTo(x,h);
			context.stroke();
		},
		mousePositionToPositionLocation = function(mX,mY){
			return {
				x:Math.floor(mX / size) - xShift,
				y:Math.floor(mY / size) - yShift
			};
		},
		mousePositionToPosition = function(mX, mY){
			var positionLocation = mousePositionToPositionLocation(mX,mY);
			return position(positionLocation.x, positionLocation.y);
		},
		position = (function(){
			var all = [];
			var makeNew = function(x,y){
				var occupied = false;
				return {
					x:x,
					y:y,
					toString:function(){return "("+x+","+y+")";},
					occupy: function(){
						occupied = true;
						createNeighborsOf(this);
					},
					draw:function(){
						if(!occupied){return;}
						var mousePosition = positionToMousePosition(this);
						context.fillRect(mousePosition.x,mousePosition.y,size,size);
					},
					vacate:function(cellBeingKilled){
						occupied = false;
						var neighborWithoutOccupiedNeighbors;
						while(neighborWithoutOccupiedNeighbors = this.neighbors.find(function(p){return !p.isOccupied() && hasNoOccupiedNeighbors(p);})){
							forget(neighborWithoutOccupiedNeighbors, cellBeingKilled);
						}
						if(hasNoOccupiedNeighbors(this)){
							forget(this, cellBeingKilled);
						}
					},
					forgetNeighbor:function(p){
						var index = this.neighbors.indexOf(p);
						if(index > -1){
							this.neighbors.splice(this.neighbors.indexOf(p), 1);
						}else{
							throw new Error("forgetting neighbor that has already been forgotten");
						}
						
					},
					isOccupied:function(){return occupied;},
					neighbors: [],
					numberOfLiveNeighbors:function(){
						var n = 0;
						for(var i=0;i<this.neighbors.length;i++){
							if(this.neighbors[i].isOccupied()){
								n++;
							}
						}
						return n;
					}
				};
			};
			var getExistingNeighbors = function(p){
				return all.filter(function(pp){return Math.abs(p.x - pp.x) < 2 && Math.abs(p.y - pp.y) < 2;});
			};
			var forget = function(p, cellBeingKilled){
				p.neighbors.map(function(pp){pp.forgetNeighbor(p);});
				var index = all.indexOf(p);
				if(index > -1){
					all.splice(index,1);
				}else{
					throw new Error("forgetting one that has already been forgotten");
				}
			};
			var hasNoOccupiedNeighbors = function(p){
				return !p.neighbors.some(function(pp){return pp.isOccupied();});
			};

			var getDiagnosis = function(){
				var positionsToVacate = [];
				var positionsToOccupy = [];
				all.map(function(p){
					var liveNeighbors = p.numberOfLiveNeighbors();
					if(p.isOccupied()){
						if(liveNeighbors < 2 || liveNeighbors > 3){
							positionsToVacate.push(p);
						}
					}else{
						if(liveNeighbors == 3){
							positionsToOccupy.push(p);
						}
					}
				});
				return {
					positionsToOccupy:positionsToOccupy,
					positionsToVacate:positionsToVacate
				};
			};
			var connectToExistingNeighbors = function(p){
				var neighbors = getExistingNeighbors(p);
				p.neighbors = neighbors;
				neighbors.map(function(pp){
					if(pp.neighbors.length == 8){
						throw new Error("position already has eight neighbors!");
					}
					pp.neighbors.push(p);
				});
			};
			var createNeighborsOf = function(p){
				get(p.x - 1, p.y - 1);
				get(p.x - 1, p.y);
				get(p.x - 1, p.y + 1);
				get(p.x, p.y - 1);
				get(p.x, p.y + 1);
				get(p.x + 1, p.y - 1);
				get(p.x + 1, p.y);
				get(p.x + 1, p.y + 1);
			};
			var get = function(x,y){
				var known = all.find(function(p){return p.x == x && p.y == y;});
				if(known){
					return known;
				}else{
					var newOne = makeNew(x,y);
					connectToExistingNeighbors(newOne);
					all.push(newOne);
					return newOne;
				}
			};
			var vacateAll = function(){
				var occupied = all.filter(function(p){return p.isOccupied();});
				occupied.map(function(p){p.vacate();});
			};
			var serialize = function(){
				return all.filter(function(p){return p.isOccupied();}).map(function(p){return p.toString();}).join("");
			};
			get.draw = function(){
				all.map(function(p){p.draw();});
			};
			get.vacateAll = vacateAll;
			get.serialize = serialize;
			get.getDiagnosis = getDiagnosis;
			get.isKnownPosition = function(p){return all.indexOf(p) > -1;};
			get.countAll = function(){return all.length;};
			get.countAlive = function(){return all.filter(function(p){return p.isOccupied();}).length;};
			return get;
		})(),
		positionToMousePosition = function(p){
			return {
				x:(p.x + xShift) * size,
				y:(p.y + yShift) * size
			};
		},
		drawHorizontalLine = function(y){
			context.beginPath();
			context.moveTo(0,y);
			context.lineTo(w,y);
			context.stroke();
		},
		doStep = function(stop){
			try{
				var diagnosis = position.getDiagnosis();
				var positionsToVacate = diagnosis.positionsToVacate;
				var positionsToOccupy = diagnosis.positionsToOccupy;
				if(positionsToVacate.length == 0 && positionsToOccupy.length == 0){
					stop();
				}
				for(var i=0;i<positionsToVacate.length;i++){
					positionsToVacate[i].vacate();
				}
				positionsToOccupy.map(function(p){position(p.x,p.y).occupy();});
			}catch(e){
				stop();
				throw e;

			}
		},
		going = false,
		interval,
		stop = function(){
			going = false;
			console.log("stopping");
			window.clearInterval(interval);
		},
		go = function(onStop){
			var sstop = function(){
				stop();
				onStop && onStop();
			};
			going = true;
			interval = window.setInterval(function(){
				doStep(sstop);
				drawAll();
			},50);
		},
		readHash = function(){
			var hash = window.location.hash;
			if(!hash){
				return;
			}
			var matches = hash.substr(1).match(/\(-?\d+,-?\d+\)/g);
			matches.map(function(m){
				var match = m.match(/^\((-?\d+),(-?\d+)\)$/);
				var x = parseInt(match[1]);
				var y = parseInt(match[2]);
				position(x,y).occupy();
			});
		},
		drawAll = function(){
			clear();
			for(var i = 0;i<nx;i++){
				drawVerticalLine(i * size);
			}
			for(var i = 0;i<ny;i++){
				drawHorizontalLine(i * size);
			}
			position.draw();
		};
	setSize(15);
	readHash();
	drawAll();

	window.go = go;
	var zoomOut = function(){clear();zoom(0.5);drawAll();};
	var zoomIn = function(){clear();zoom(2);drawAll();};
	var left = function(){xShift += Math.floor(nx/4);drawAll();};
	var right = function(){xShift -= Math.floor(nx/4);drawAll();};
	var up = function(){yShift += Math.floor(ny/4);drawAll();};
	var down = function(){yShift -= Math.floor(ny/4);drawAll();};
	window.record = function(){
		window.location.hash = position.serialize();
	};
	window.health = function(){
		var all = position.countAll();
		var alive = position.countAlive();
		return {
			all:all,
			alive:alive,
			ratio:all/alive
		};
	};
	window.alive = function(x,y){position(x,y).occupy();drawAll();};
	window.addEventListener("keydown",function(e){
		if(e.key == "+"){
			zoomIn();
		}
		if(e.key == "-"){
			zoomOut();
		}
		if(e.key == "ArrowLeft"){
			left();
		}
		if(e.key == "ArrowRight"){
			right();
		}
		if(e.key == "ArrowUp"){
			up();
		}
		if(e.key == "ArrowDown"){
			down();
		}
		if(e.key == "g"){
			if(going){
				stop();
			}else{
				go();
			}
		}
		if(e.key == "c"){
			position.vacateAll();
			drawAll();
		}

	});
})();
</script>
</html>
<html>
<body style="padding:0px;margin:0px"></body>
<script>
(function(){
	var space = (function(){
		var w = document.body.offsetWidth,
			h = document.body.offsetHeight,
			size = 20,
			nx = Math.ceil(w / size),
			ny = Math.ceil(h / size),
			c = (function(){
				var canvas = document.createElement("canvas");
				canvas.setAttribute("width", w);
				canvas.setAttribute("height", h);
				document.body.appendChild(canvas);
				var context = canvas.getContext("2d");
				var initializeContext = function(){
					context.strokeStyle = '#000';
					context.lineWidth = 0.1;
					context.fillStyle = '#000';
				};
				initializeContext();
				canvas.addEventListener('click',function(e){
					var p = mousePositionToPosition(e.clientX, e.clientY);
					var existingCell = cells.getCellOnPosition(p);
					if(existingCell){
						existingCell.destroy();
					}else{
						cells.add(p);
					}
					drawAll();
				});
				return {
					context:context,
					clear:function(){canvas.width = w;initializeContext();}
				};
			})(),
			context = c.context,
			clear = c.clear,
			drawVerticalLine = function(x){
				context.beginPath();
				context.moveTo(x,0);
				context.lineTo(x,h);
				context.stroke();
			},
			mousePositionToPosition = function(mX, mY){
				return position(Math.floor(mX / size), Math.floor(mY / size));
			},
			position = (function(){
				var all = [];
				var makeNew = function(x,y){
					var occupied = false;
					return {
						x:x,
						y:y,
						occupy: function(){
							occupied = true;
							createNeighborsOf(this);
						},
						vacate:function(){
							occupied = false;
							var neighborWithoutOccupiedNeighbors;
							while(neighborWithoutOccupiedNeighbors = this.neighbors.find(function(p){return !p.isOccupied() && hasNoOccupiedNeighbors(p);})){
								forget(neighborWithoutOccupiedNeighbors);
							}
							if(hasNoOccupiedNeighbors(this)){
								forget(this);
							}
						},
						forgetNeighbor:function(p){
							this.neighbors.splice(this.neighbors.indexOf(p), 1);
						},
						isOccupied:function(){return occupied;},
						neighbors: []
					};
				};
				var getExistingNeighbors = function(p){
					return all.filter(function(pp){return Math.abs(p.x - pp.x) < 2 && Math.abs(p.y - pp.y) < 2;});
				};
				var forget = function(p){
					p.neighbors.map(function(pp){pp.forgetNeighbor(p);});
					all.splice(all.indexOf(p),1);
				};
				var hasNoOccupiedNeighbors = function(p){
					return !p.neighbors.some(function(pp){return pp.isOccupied();});
				};
				var connectToExistingNeighbors = function(p){
					var neighbors = getExistingNeighbors(p);
					p.neighbors = neighbors;
					neighbors.map(function(pp){pp.neighbors.push(p);});
				};
				var createNeighborsOf = function(p){
					get(p.x - 1, p.y - 1);
					get(p.x - 1, p.y);
					get(p.x - 1, p.y + 1);
					get(p.x, p.y - 1);
					get(p.x, p.y + 1);
					get(p.x + 1, p.y - 1);
					get(p.x + 1, p.y);
					get(p.x + 1, p.y + 1);
				};
				var get = function(x,y){
					var known = all.find(function(p){return p.x == x && p.y == y;});
					if(known){
						return known;
					}else{
						var newOne = makeNew(x,y);
						connectToExistingNeighbors(newOne);
						all.push(newOne);
						return newOne;
					}
				};
				get.all = function(){return all;};
				return get;
			})(),
			positionToMousePosition = function(p){
				return {
					x:p.x * size,
					y:p.y * size
				};
			},
			drawHorizontalLine = function(y){
				context.beginPath();
				context.moveTo(0,y);
				context.lineTo(w,y);
				context.stroke();
			},
			cells = (function(){
				var cell = function(p){
					console.log("creating cell");
					p.occupy();
					return {
						draw: function(){
							var mousePosition = positionToMousePosition(p);
							context.fillRect(mousePosition.x,mousePosition.y,size,size);
						},
						destroy:function(){
							p.vacate();
							liveCells.splice(liveCells.indexOf(this), 1);
						},
						position:p
					}
				};
				var liveCells = [];
				return {
					add:function(p){
						if(!p.isOccupied()){
							liveCells.push(cell(p));
						}
					},
					draw:function(){liveCells.map(function(c){c.draw();});},
					getCellOnPosition:function(p){return liveCells.find(function(c){return c.position == p;});}
				};
			})(),
			drawAll = function(){
				clear();
				for(var i = 0;i<nx;i++){
					drawVerticalLine(i * size);
				}
				for(var i = 0;i<ny;i++){
					drawHorizontalLine(i * size);
				}
				cells.draw();
				console.log("known positions: ",position.all().length);
			};
		drawAll();
		window.doStep = function(){
			drawAll();
		};
	})();
})();
</script>
</html>
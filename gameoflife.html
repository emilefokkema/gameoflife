<html>
<head>
	<style>
		body{overflow: hidden;}
		.menu{
			position:absolute;
			display:none;
			width:150px;
			background-color: #fff;
			min-height: 30px;
			border: 1pt solid #000;
		}
		.option{
			height: 30px;
			padding:3px;
			font-family: Arial;
			cursor: pointer;
		}
		.option:hover{
			background-color:#ccc;
		}
		.input {
			position: fixed;
			left:50%;
			top:50%;
			width:400px;
			height: 300px;
			background-color: #ddd;
			transform: translate(-50%,-50%);
		}
		.input textarea{
			position: absolute;
			left:0px;
			top:0px;
			width: 100%;
			height: 80%;
		}
		.input input[type="button"]{
			position: absolute;
			bottom: 0px;
		}
	</style>
</head>
<body style="padding:0px;margin:0px"></body>
<script>
(function(){
	
	var w = document.body.offsetWidth,
		h = document.body.offsetHeight,
		size, nx, ny,
		setSize = function(s){
			size = s;
			nx = Math.ceil(w / size);
			ny = Math.ceil(h / size);
		},
		zoom = function(factor){
			var centerLocation = mousePositionToPositionLocation(w/2, h/2);
			var newSize;
			if(factor < 1){
				newSize = Math.max(1, Math.floor(size * factor));
			}else{
				newSize = size * factor;
			}
			setSize(newSize);
			xShift = Math.floor(w/(2 * size) - centerLocation.x);
			yShift = Math.floor(h/(2 * size) - centerLocation.y);
		},
		xShift = 0,
		yShift = 0,
		c = (function(){
			var canvas = document.createElement("canvas");
			canvas.setAttribute("width", w);
			canvas.setAttribute("height", h);
			document.body.appendChild(canvas);
			var context = canvas.getContext("2d");
			var initializeContext = function(){
				context.strokeStyle = '#000';
				context.lineWidth = 0.1;
				context.fillStyle = '#000';
			};
			initializeContext();
			canvas.addEventListener('click',function(e){
				if(e.shiftKey){
					var loc = mousePositionToPositionLocation(e.clientX, e.clientY);
					selection.select(loc.x, loc.y);
					drawAll();
					return;
				}
				menu.hide();
				selection.clear();
				var p = mousePositionToPosition(e.clientX, e.clientY);
				
				if(p.isOccupied()){
					p.vacate();
				}else{
					p.occupy();
				}
				drawAll();
			});
			canvas.addEventListener('contextmenu',function(e){
				e.preventDefault();
				menu.show(e.clientX, e.clientY);
				return false;
			});
			return {
				context:context,
				clear:function(){canvas.width = w;initializeContext();}
			};
		})(),
		menu = (function(){
			var currentX, currentY;
			var div = document.createElement("div");
			div.setAttribute("class","menu");
			document.body.appendChild(div);
			var addOption = function(text, f){
				var option = document.createElement('div');
				option.setAttribute("class","option");
				option.appendChild(document.createTextNode(text));
				option.addEventListener('click', function(){
					hide();
					f(currentX, currentY);
				});
				div.appendChild(option);
				return function(){div.removeChild(option);}
			};
			var show = function(x,y){
				var loc = mousePositionToPositionLocation(x,y);
				currentX = loc.x;
				currentY = loc.y;
				div.style.display = "initial";
				div.style.left = x + "px";
				div.style.top = y + "px";
			};
			var hide = function(){div.style.display = "none"};
			return {
				addOption:addOption,
				show:show,
				hide:hide
			}
		})(),
		selection = (function(){
			var present = false, removeMenuOption = null, minX, minY, maxX, maxY;
			var addMenuOptions = function(){
				var remove = [];
				remove.push(menu.addOption('log selection',
					function(){
						console.log(position.getAllInBox({
							minX:minX,
							maxX:maxX,
							minY:minY,
							maxY:maxY
						}));
					}));
				remove.push(menu.addOption('copy',function(x,y){
					var positions = position.getAllInBox({
							minX:minX,
							maxX:maxX,
							minY:minY,
							maxY:maxY
						});
					clipboard.copy(positions.map(function(p){return {
							x: p.x - minX,
							y: p.y - minY
						};}));
				}));
				remove.push(menu.addOption('alive', function(){
					for(var x=minX;x<=maxX;x++){
						for(var y=minY;y<=maxY;y++){
							position(x,y).occupy();
						}
					}
					drawAll();
				}));
				return function(){
					remove.map(function(f){f();});
					remove = [];
				};
			};
			var select = function(x,y){
				if(!present){
					minX = maxX = x;
					minY = maxY = y;
					present = true;
				}else{
					if(x > minX){
						maxX = x;
					}else{
						maxX = minX;
						minX = x;
					}
					if(y > minY){
						maxY = y;
					}else{
						maxY = minY;
						minY = y;
					}
				}
				!removeMenuOption && (removeMenuOption = addMenuOptions());
			};
			var draw = function(){
				if(!present){return;}
				var style = context.strokeStyle;
				var lineWidth = context.lineWidth;
				context.strokeStyle = '#00f';
				context.lineWidth = 2;
				var minLoc = positionToMousePosition({x:minX,y:minY});
				var maxLoc = positionToMousePosition({x:maxX + 1,y:maxY + 1});
				context.strokeRect(minLoc.x, minLoc.y, maxLoc.x - minLoc.x, maxLoc.y - minLoc.y);
				context.strokeStyle = style;
				context.lineWidth = lineWidth;
			};
			var clear = function(){
				present = false;
				removeMenuOption && removeMenuOption();
				removeMenuOption = null;
			};
			return {
				select:select,
				draw:draw,
				clear:clear
			};
		})(),
		input = (function(){
			var open = false;
			var div = document.createElement('div');
			div.setAttribute("class","input");
			var text = document.createElement('textarea');
			var button = document.createElement('input');
			button.setAttribute('type','button');
			button.setAttribute('value','OK');
			div.appendChild(text);
			div.appendChild(button);
			var show = function(){
				open = true;
				div.style.display = 'initial';
			};
			var hide = function(){
				open = false;
				div.style.display = 'none';
			};
			var handler = function(v){};
			document.body.appendChild(div);
			button.addEventListener('click',function(){
				handler(text.value);
			});
			hide();
			var f = function(resultHandler){
				show();
				handler = function(v){
					hide();
					resultHandler(v);
				};
			};
			f.isOpen = function(){return open;};
			return f;
		})(),
		clipboard = (function(){
			var relativePositions, removeMenuOption;
			var paste = function(x, y){
				relativePositions.map(function(p){
					position(x + p.x,y + p.y).occupy();
				});
				drawAll();
			};
			var copy = function(_relativePositions){
				relativePositions = _relativePositions;
				!removeMenuOption && (removeMenuOption = menu.addOption('paste', paste));
			};
			
			return {copy:copy};
		})(),
		context = c.context,
		clear = c.clear,
		drawVerticalLine = function(x){
			context.beginPath();
			context.moveTo(x,0);
			context.lineTo(x,h);
			context.stroke();
		},
		mousePositionToPositionLocation = function(mX,mY){
			return {
				x:Math.floor(mX / size) - xShift,
				y:Math.floor(mY / size) - yShift
			};
		},
		mousePositionToPosition = function(mX, mY){
			var positionLocation = mousePositionToPositionLocation(mX,mY);
			return position(positionLocation.x,positionLocation.y);
		},
		position = (function(){
			var allColumns = [];
			var get, getColumn;
			var connectToNeighboringColumns = function(c){
				allColumns.map(function(cc){
					if(Math.abs(cc.x - c.x) < 2){
						c.neighbors.push(cc);
						cc.neighbors.push(c);
					}
				});
			};
			var makeNewColumn = function(x, forget){
				var newOne;
				var all = [];
				var neighbors = [];
				var forgetColumn = function(){
					neighbors.map(function(c){c.forgetNeighbor(newOne);});
					forget();
				};
				var connectToNeighboringPositions = function(p){
					all.map(function(pp){
						if(Math.abs(pp.y - p.y) < 2){
							p.neighbors.push(pp);
							pp.neighbors.push(p);
						}
					});
					if(p.x == x){
						neighbors.map(function(c){c.connectToNeighboringPositions(p);});
					}
				};
				var getDiagnosis = function(positionsToVacate, positionsToOccupy){
					all.map(function(p){
						if(!p.environmentHasChanged()){return;}
						p.noEnvironmentChange();
						var liveNeighbors = p.numberOfLiveNeighbors();
						if(p.isOccupied()){
							if(liveNeighbors < 2 || liveNeighbors > 3){
								positionsToVacate.push(p);
							}
						}else{
							if(liveNeighbors == 3){
								positionsToOccupy.push(p);
							}
						}
					});
				};
				var makeNewPosition = function(y){
					var occupied = false;
					var environmentChanged = true;
					var newPosition = {
						x:x,
						y:y,
						toString:function(){return "("+x+","+y+")";},
						occupy:function(){
							occupied = true;
							createNeighborsOf(this);
							this.neighbors.map(function(p){p.notifyEnvironmentChange();});
						},
						draw:function(){
							if(!occupied){return;}
							var mousePosition = positionToMousePosition(this);
							context.fillRect(mousePosition.x,mousePosition.y,size,size);
						},
						vacate:function(){
							occupied = false;
							var neighborWithoutOccupiedNeighbors;
							while(neighborWithoutOccupiedNeighbors = this.neighbors.find(function(p){return !p.isOccupied() && p.hasNoOccupiedNeighbors();})){
								neighborWithoutOccupiedNeighbors.forget();
							}
							if(this.hasNoOccupiedNeighbors()){
								this.forget();
							}
							this.neighbors.map(function(p){p.notifyEnvironmentChange();});
						},
						forgetNeighbor:function(p){
							var index = this.neighbors.indexOf(p);
							if(index > -1){
								this.neighbors.splice(this.neighbors.indexOf(p), 1);
							}else{
								throw new Error("forgetting neighbor that has already been forgotten");
							}
							
						},
						isOccupied:function(){return occupied;},
						neighbors: [],
						beForgottenByNeighbors:function(){
							var self = this;
							this.neighbors.map(function(pp){pp.forgetNeighbor(self);});
						},
						numberOfLiveNeighbors:function(){
							var n = 0;
							for(var i=0;i<this.neighbors.length;i++){
								if(this.neighbors[i].isOccupied()){
									n++;
								}
							}
							return n;
						},
						hasNoOccupiedNeighbors:function(){
							return !this.neighbors.some(function(pp){return pp.isOccupied();});
						},
						environmentHasChanged: function(){return environmentChanged;},
						noEnvironmentChange: function(){environmentChanged = false;},
						notifyEnvironmentChange: function(){environmentChanged = true;},
						forget:function(){
							this.beForgottenByNeighbors();
							all.splice(all.indexOf(this),1);
							if(all.length == 0){
								forgetColumn();
							}
						}
					};
					return newPosition;
				};
				var draw = function(){
					all.map(function(p){p.draw();});
				};
				var getAllOccupiedPositions = function(){
					return all.filter(function(p){return p.isOccupied();});
				};
				var getIfExistsOnY = function(y){
					return all.find(function(p){return p.y == y});
				};
				var getAllBetween = function(yMin, yMax){
					return all.filter(function(p){return p.isOccupied() && p.y >= yMin && p.y <= yMax;});
				};
				newOne = function(y){
					var known = all.find(function(p){return p.y == y});
					if(known){
						return known;
					}
					var newPosition = makeNewPosition(y);
					connectToNeighboringPositions(newPosition);
					all.push(newPosition);
					return newPosition;
				};
				newOne.x = x;
				newOne.count = function(){return all.length;};
				newOne.neighbors = neighbors;
				newOne.draw = draw;
				newOne.getAllBetween = getAllBetween;
				newOne.getIfExistsOnY = getIfExistsOnY;
				newOne.forgetNeighbor = function(c){neighbors.splice(neighbors.indexOf(c), 1);};
				newOne.getAllOccupiedPositions = getAllOccupiedPositions;
				newOne.getDiagnosis = getDiagnosis;
				newOne.connectToNeighboringPositions = connectToNeighboringPositions;
				return newOne;
			};
			var createNeighborsOf = function(p){
				var c = getColumn(p.x - 1);
				c(p.y - 1);
				c(p.y);
				c(p.y + 1);
				c = getColumn(p.x);
				c(p.y - 1);
				c(p.y + 1);
				c = getColumn(p.x + 1);
				c(p.y - 1);
				c(p.y);
				c(p.y + 1);
			};
			var getDiagnosis = function(){
				var positionsToVacate = [];
				var positionsToOccupy = [];
				allColumns.map(function(c){
					c.getDiagnosis(positionsToVacate, positionsToOccupy);
				});
				return {
					positionsToVacate:positionsToVacate,
					positionsToOccupy:positionsToOccupy
				};
			};
			var getAllOccupiedPositions = function(){
				var allOccupiedPositions = [];
				allColumns.map(function(c){
					c.getAllOccupiedPositions().map(function(p){allOccupiedPositions.push(p);});
				});
				return allOccupiedPositions;
			};
			var serialize = function(){
				return getAllOccupiedPositions().map(function(p){return p.toString();}).join("");
			};
			var vacateAll = function(){
				getAllOccupiedPositions().map(function(p){p.vacate();});
			};
			var getIfExistsOnXY = function(x,y){
				var col = allColumns.find(function(c){return c.x == x});
				if(!col){
					return col;
				}
				return col.getIfExistsOnY(y);
			};
			var getAllInBox = function(box){
				var all = [];
				allColumns.filter(function(c){return c.x >= box.minX && c.x <= box.maxX;}).map(function(c){
					c.getAllBetween(box.minY, box.maxY).map(function(p){all.push(p);});
				});
				return all;
			};
			getColumn = function(x){
				var known = allColumns.find(function(c){return c.x == x});
				if(known){
					return known;
				}
				var newOne;
				var forget = function(){allColumns.splice(allColumns.indexOf(newOne), 1);};
				newOne = makeNewColumn(x, forget);
				connectToNeighboringColumns(newOne);
				allColumns.push(newOne);
				return newOne;
			};
			get = function(x,y){
				return getColumn(x)(y);
			};
			get.getDiagnosis = getDiagnosis;
			get.vacateAll = vacateAll;
			get.serialize = serialize;
			get.getAllInBox = getAllInBox;
			get.getIfExistsOnXY = getIfExistsOnXY;
			get.countAlive = function(){return getAllOccupiedPositions().length;};
			get.countAll = function(){
				var n = 0;
				allColumns.map(function(c){n += c.count();});
				return n;
			};
			get.draw = function(){allColumns.map(function(c){c.draw();});};
			return get;
		})(),
		positionToMousePosition = function(p){
			return {
				x:(p.x + xShift) * size,
				y:(p.y + yShift) * size
			};
		},
		drawHorizontalLine = function(y){
			context.beginPath();
			context.moveTo(0,y);
			context.lineTo(w,y);
			context.stroke();
		},
		stepCount = 0,
		doStep = function(stop){
			try{
				var diagnosis = position.getDiagnosis();
				var positionsToVacate = diagnosis.positionsToVacate;
				var positionsToOccupy = diagnosis.positionsToOccupy;
				if(positionsToVacate.length == 0 && positionsToOccupy.length == 0){
					stop && stop();
				}
				for(var i=0;i<positionsToVacate.length;i++){
					positionsToVacate[i].vacate();
				}
				positionsToOccupy.map(function(p){position(p.x,p.y).occupy();});
				stepCount++;
			}catch(e){
				stop && stop();
				throw e;

			}
		},
		going = false,
		interval,
		stop = function(){
			going = false;
			console.log("stopping at " + stepCount);
			window.clearInterval(interval);
		},
		go = function(onStop){
			var sstop = function(){
				stop();
				onStop && onStop();
			};
			going = true;
			interval = window.setInterval(function(){
				doStep(sstop);
				drawAll();
			},50);
		},
		parseRLEBody = function(body, occupy){
			var parts = body.replace(/\s*/g,"").match(/\d*[bo\$]/g);
			var x = 0, y = 0;
			parts.map(function(p){
				var match = p.match(/^(\d*)([bo\$])$/);
				var number = match[1] ? parseInt(match[1]) : 1;
				for(var i=0;i<number;i++){
					if(match[2] == "$"){
						x = 0;
						y++;
					}else{
						if(match[2] == "o"){
							occupy(x,y);
						}
						x++;
					} 
				}
			});
		},
		readHash = function(){
			var hash = window.location.hash;
			if(!hash){
				return;
			}
			parseRLEBody(hash.substr(1), function(x,y){position(x,y).occupy()});
		},
		drawAll = function(){
			clear();
			for(var i = 0;i<nx;i++){
				drawVerticalLine(i * size);
			}
			for(var i = 0;i<ny;i++){
				drawHorizontalLine(i * size);
			}
			selection.draw();
			position.draw();
		};
	menu.addOption('parse RLE',function(x,y){
		input(function(v){
			if(!v){return;}
			position.vacateAll();
			parseRLEBody(v, function(xx,yy){position(xx+x,yy+y).occupy();});
			drawAll();
		});
	});
	setSize(15);
	readHash();
	drawAll();

	window.go = go;
	var zoomOut = function(){clear();zoom(0.5);drawAll();};
	var zoomIn = function(){clear();zoom(2);drawAll();};
	var left = function(){xShift += Math.floor(nx/4);drawAll();};
	var right = function(){xShift -= Math.floor(nx/4);drawAll();};
	var up = function(){yShift += Math.floor(ny/4);drawAll();};
	var down = function(){yShift -= Math.floor(ny/4);drawAll();};
	window.getStepCount = function(){return stepCount;};
	window.resetStepCount = function(){stepCount = 0;}
	window.health = function(){
		var all = position.countAll();
		var alive = position.countAlive();
		return {
			all:all,
			alive:alive,
			ratio:all/alive
		};
	};
	window.alive = function(x,y){position(x,y).occupy();};
	window.parseRLEBody = function(body){
		position.vacateAll();
		parseRLEBody(body, function(x,y){position(x,y).occupy();});
		drawAll();
	};
	window.copyFromRLE = function(body){
		var relativePositions = [];
		parseRLEBody(body, function(x,y){
			relativePositions.push({x:x,y:y});
		});
		clipboard.copy(relativePositions);
	};
	window.addEventListener("keydown",function(e){
		if(input.isOpen()){return true;}
		if(e.key == "+"){
			zoomIn();
		}
		if(e.key == "-"){
			zoomOut();
		}
		if(e.key == "ArrowLeft"){
			left();
		}
		if(e.key == "ArrowRight"){
			right();
		}
		if(e.key == "ArrowUp"){
			up();
		}
		if(e.key == "ArrowDown"){
			down();
		}
		if(e.key == "g"){
			if(going){
				stop();
			}else{
				go();
			}
		}
		if(e.key == "c"){
			position.vacateAll();
			stepCount = 0;
			drawAll();
		}
		if(e.key == "s"){
			doStep();
			drawAll();
			console.log("now at step "+stepCount);
		}
	});
})();
</script>
</html>
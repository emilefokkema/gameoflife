<html>
<body style="padding:0px;margin:0px"></body>
<script>
(function(){
	
	var w = document.body.offsetWidth,
		h = document.body.offsetHeight,
		size, nx, ny,
		setSize = function(s){
			size = s;
			nx = Math.ceil(w / size);
			ny = Math.ceil(h / size);
		},
		zoom = function(factor){
			var centerLocation = mousePositionToPositionLocation(w/2, h/2);
			var newSize;
			if(factor < 1){
				newSize = Math.max(1, Math.floor(size * factor));
			}else{
				newSize = size * factor;
			}
			setSize(newSize);
			xShift = Math.floor(w/(2 * size) - centerLocation.x);
			yShift = Math.floor(h/(2 * size) - centerLocation.y);
		},
		xShift = 0,
		yShift = 0,
		c = (function(){
			var canvas = document.createElement("canvas");
			canvas.setAttribute("width", w);
			canvas.setAttribute("height", h);
			document.body.appendChild(canvas);
			var context = canvas.getContext("2d");
			var initializeContext = function(){
				context.strokeStyle = '#000';
				context.lineWidth = 0.1;
				context.fillStyle = '#000';
			};
			initializeContext();
			canvas.addEventListener('click',function(e){
				var p = mousePositionToPosition(e.clientX, e.clientY);
				
				if(p.isOccupied()){
					p.vacate();
				}else{
					p.occupy();
				}
				drawAll();
			});
			canvas.addEventListener('contextmenu',function(e){
				e.preventDefault();
				var loc = mousePositionToPositionLocation(e.clientX, e.clientY);
				console.log(position.getIfExistsOnXY(loc.x, loc.y));
				return false;
			});
			return {
				context:context,
				clear:function(){canvas.width = w;initializeContext();}
			};
		})(),
		context = c.context,
		clear = c.clear,
		drawVerticalLine = function(x){
			context.beginPath();
			context.moveTo(x,0);
			context.lineTo(x,h);
			context.stroke();
		},
		mousePositionToPositionLocation = function(mX,mY){
			return {
				x:Math.floor(mX / size) - xShift,
				y:Math.floor(mY / size) - yShift
			};
		},
		mousePositionToPosition = function(mX, mY){
			var positionLocation = mousePositionToPositionLocation(mX,mY);
			return position(positionLocation.x)(positionLocation.y);
		},
		position = (function(){
			var allColumns = [];
			var get;
			var connectToNeighboringColumns = function(c){
				allColumns.map(function(cc){
					if(Math.abs(cc.x - c.x) < 2){
						c.neighbors.push(cc);
						cc.neighbors.push(c);
					}
				});
			};
			var makeNewColumn = function(x, forget){
				var newOne;
				var all = [];
				var neighbors = [];
				var forgetColumn = function(){
					neighbors.map(function(c){c.forgetNeighbor(newOne);});
					forget();
				};
				var connectToNeighboringPositions = function(p){
					all.map(function(pp){
						if(Math.abs(pp.y - p.y) < 2){
							p.neighbors.push(pp);
							pp.neighbors.push(p);
						}
					});
					if(p.x == x){
						neighbors.map(function(c){c.connectToNeighboringPositions(p);});
					}
				};
				var getDiagnosis = function(){
					var positionsToVacate = [];
					var positionsToOccupy = [];
					all.map(function(p){
						var liveNeighbors = p.numberOfLiveNeighbors();
						if(p.isOccupied()){
							if(liveNeighbors < 2 || liveNeighbors > 3){
								positionsToVacate.push(p);
							}
						}else{
							if(liveNeighbors == 3){
								positionsToOccupy.push(p);
							}
						}
					});
					return {
						positionsToOccupy:positionsToOccupy,
						positionsToVacate:positionsToVacate
					};
				};
				var makeNewPosition = function(y){
					var occupied = false;
					var newPosition = {
						x:x,
						y:y,
						toString:function(){return "("+x+","+y+")";},
						occupy:function(){
							occupied = true;
							createNeighborsOf(this);
						},
						draw:function(){
							if(!occupied){return;}
							var mousePosition = positionToMousePosition(this);
							context.fillRect(mousePosition.x,mousePosition.y,size,size);
						},
						vacate:function(){
							occupied = false;
							var neighborWithoutOccupiedNeighbors;
							while(neighborWithoutOccupiedNeighbors = this.neighbors.find(function(p){return !p.isOccupied() && p.hasNoOccupiedNeighbors();})){
								neighborWithoutOccupiedNeighbors.forget();
							}
							if(this.hasNoOccupiedNeighbors()){
								this.forget();
							}
						},
						forgetNeighbor:function(p){
							var index = this.neighbors.indexOf(p);
							if(index > -1){
								this.neighbors.splice(this.neighbors.indexOf(p), 1);
							}else{
								throw new Error("forgetting neighbor that has already been forgotten");
							}
							
						},
						isOccupied:function(){return occupied;},
						neighbors: [],
						beForgottenByNeighbors:function(){
							var self = this;
							this.neighbors.map(function(pp){pp.forgetNeighbor(self);});
						},
						numberOfLiveNeighbors:function(){
							var n = 0;
							for(var i=0;i<this.neighbors.length;i++){
								if(this.neighbors[i].isOccupied()){
									n++;
								}
							}
							return n;
						},
						hasNoOccupiedNeighbors:function(){
							return !this.neighbors.some(function(pp){return pp.isOccupied();});
						},
						forget:function(){
							this.beForgottenByNeighbors();
							all.splice(all.indexOf(this),1);
							if(all.length == 0){
								forgetColumn();
							}
						}
					};
					return newPosition;
				};
				var draw = function(){
					all.map(function(p){p.draw();});
				};
				var getAllOccupiedPositions = function(){
					return all.filter(function(p){return p.isOccupied();});
				};
				var getIfExistsOnY = function(y){
					return all.find(function(p){return p.y == y});
				};
				newOne = function(y){
					var known = all.find(function(p){return p.y == y});
					if(known){
						return known;
					}
					var newPosition = makeNewPosition(y);
					connectToNeighboringPositions(newPosition);
					all.push(newPosition);
					return newPosition;
				};
				newOne.x = x;
				newOne.count = function(){return all.length;};
				newOne.neighbors = neighbors;
				newOne.draw = draw;
				newOne.getIfExistsOnY = getIfExistsOnY;
				newOne.forgetNeighbor = function(c){neighbors.splice(neighbors.indexOf(c), 1);};
				newOne.getAllOccupiedPositions = getAllOccupiedPositions;
				newOne.getDiagnosis = getDiagnosis;
				newOne.connectToNeighboringPositions = connectToNeighboringPositions;
				return newOne;
			};
			var createNeighborsOf = function(p){
				var c = get(p.x - 1);
				c(p.y - 1);
				c(p.y);
				c(p.y + 1);
				c = get(p.x);
				c(p.y - 1);
				c(p.y + 1);
				c = get(p.x + 1);
				c(p.y - 1);
				c(p.y);
				c(p.y + 1);
			};
			var getDiagnosis = function(){
				var positionsToVacate = [];
				var positionsToOccupy = [];
				allColumns.map(function(c){
					var diagnosis = c.getDiagnosis();
					diagnosis.positionsToVacate.map(function(p){positionsToVacate.push(p);});
					diagnosis.positionsToOccupy.map(function(p){positionsToOccupy.push(p);});
				});
				return {
					positionsToVacate:positionsToVacate,
					positionsToOccupy:positionsToOccupy
				};
			};
			var getAllOccupiedPositions = function(){
				var allOccupiedPositions = [];
				allColumns.map(function(c){
					c.getAllOccupiedPositions().map(function(p){allOccupiedPositions.push(p);});
				});
				return allOccupiedPositions;
			};
			var serialize = function(){
				return getAllOccupiedPositions().map(function(p){return p.toString();}).join("");
			};
			var vacateAll = function(){
				getAllOccupiedPositions().map(function(p){p.vacate();});
			};
			var getIfExistsOnXY = function(x,y){
				var col = allColumns.find(function(c){return c.x == x});
				if(!col){
					return col;
				}
				return col.getIfExistsOnY(y);
			};
			get = function(x){
				var known = allColumns.find(function(c){return c.x == x});
				if(known){
					return known;
				}
				var newOne;
				var forget = function(){allColumns.splice(allColumns.indexOf(newOne), 1);};
				newOne = makeNewColumn(x, forget);
				connectToNeighboringColumns(newOne);
				allColumns.push(newOne);
				return newOne;
			};
			get.getDiagnosis = getDiagnosis;
			get.vacateAll = vacateAll;
			get.serialize = serialize;
			get.getIfExistsOnXY = getIfExistsOnXY;
			get.countAlive = function(){return getAllOccupiedPositions().length;};
			get.countAll = function(){
				var n = 0;
				allColumns.map(function(c){n += c.count();});
				return n;
			};
			get.draw = function(){allColumns.map(function(c){c.draw();});};
			return get;
		})(),
		positionToMousePosition = function(p){
			return {
				x:(p.x + xShift) * size,
				y:(p.y + yShift) * size
			};
		},
		drawHorizontalLine = function(y){
			context.beginPath();
			context.moveTo(0,y);
			context.lineTo(w,y);
			context.stroke();
		},
		stepCount = 0,
		doStep = function(stop){
			try{
				var diagnosis = position.getDiagnosis();
				var positionsToVacate = diagnosis.positionsToVacate;
				var positionsToOccupy = diagnosis.positionsToOccupy;
				if(positionsToVacate.length == 0 && positionsToOccupy.length == 0){
					stop && stop();
				}
				for(var i=0;i<positionsToVacate.length;i++){
					positionsToVacate[i].vacate();
				}
				positionsToOccupy.map(function(p){position(p.x)(p.y).occupy();});
				stepCount++;
			}catch(e){
				stop && stop();
				throw e;

			}
		},
		going = false,
		interval,
		stop = function(){
			going = false;
			console.log("stopping at " + stepCount);
			window.clearInterval(interval);
		},
		go = function(onStop){
			var sstop = function(){
				stop();
				onStop && onStop();
			};
			going = true;
			interval = window.setInterval(function(){
				doStep(sstop);
				drawAll();
			},50);
		},
		readHash = function(){
			var hash = window.location.hash;
			if(!hash){
				return;
			}
			var matches = hash.substr(1).match(/\(-?\d+,-?\d+\)/g);
			matches.map(function(m){
				var match = m.match(/^\((-?\d+),(-?\d+)\)$/);
				var x = parseInt(match[1]);
				var y = parseInt(match[2]);
				position(x)(y).occupy();
			});
		},
		drawAll = function(){
			clear();
			for(var i = 0;i<nx;i++){
				drawVerticalLine(i * size);
			}
			for(var i = 0;i<ny;i++){
				drawHorizontalLine(i * size);
			}
			position.draw();
		};
	setSize(15);
	readHash();
	drawAll();

	window.go = go;
	var zoomOut = function(){clear();zoom(0.5);drawAll();};
	var zoomIn = function(){clear();zoom(2);drawAll();};
	var left = function(){xShift += Math.floor(nx/4);drawAll();};
	var right = function(){xShift -= Math.floor(nx/4);drawAll();};
	var up = function(){yShift += Math.floor(ny/4);drawAll();};
	var down = function(){yShift -= Math.floor(ny/4);drawAll();};
	window.record = function(){
		window.location.hash = position.serialize();
	};
	window.getStepCount = function(){return stepCount;};
	window.resetStepCount = function(){stepCount = 0;}
	window.health = function(){
		var all = position.countAll();
		var alive = position.countAlive();
		return {
			all:all,
			alive:alive,
			ratio:all/alive
		};
	};
	window.alive = function(x,y){position(x)(y).occupy();drawAll();};
	window.addEventListener("keydown",function(e){
		if(e.key == "+"){
			zoomIn();
		}
		if(e.key == "-"){
			zoomOut();
		}
		if(e.key == "ArrowLeft"){
			left();
		}
		if(e.key == "ArrowRight"){
			right();
		}
		if(e.key == "ArrowUp"){
			up();
		}
		if(e.key == "ArrowDown"){
			down();
		}
		if(e.key == "g"){
			if(going){
				stop();
			}else{
				go();
			}
		}
		if(e.key == "c"){
			position.vacateAll();
			stepCount = 0;
			drawAll();
		}
		if(e.key == "s"){
			doStep();
			drawAll();
			console.log("now at step "+stepCount);
		}
	});
})();
</script>
</html>
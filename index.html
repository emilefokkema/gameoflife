<html>
<head>
	<LINK href="gameoflife.css" rel="stylesheet" type="text/css" />
	 <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
</head>
<body style="padding:0px;margin:0px"></body>
<script src="quadtree.js"></script>
<script>
(function(){
	var interpolation = function(y0, x1, c){
		var a = y0 / (1 - Math.exp(-c*x1)), b = y0 - a;
		return function(x){
			return a * Math.exp(-c*x) + b;
		};
	};
	var w = document.body.offsetWidth,
		h = document.body.offsetHeight,
		size, nx, ny,
		setSize = function(s){
			size = s;
			nx = Math.ceil(w / size);
			ny = Math.ceil(h / size);
		},
		zoom = function(factor, centerX, centerY){
			clear();
			var pCenter = mousePositionToPositionLocation(centerX, centerY);
			var newSize;
			if(factor < 1){
				newSize = Math.max(1, Math.floor(size * factor));
			}else{
				newSize = size * factor;
			}
			if(newSize != size){
				setSize(newSize);
				xShift = Math.floor(centerX/size - pCenter.x);
				yShift = Math.floor(centerY/size - pCenter.y);
			}
			drawAll();
		},
		xShift = 0,
		yShift = 0,
		currentDrag = null,
		makeDrag = function(){
			var origXShift = xShift;
			var origYShift = yShift;
			return {
				drag:function(dx, dy){
					xShift = origXShift + Math.floor(dx / size);
					yShift = origYShift + Math.floor(dy / size);
					drawAll();
				}
			};
		},
		c = (function(){
			var dragger = null;
			var dragHappened = false;
			var canvas = document.createElement("canvas");
			canvas.setAttribute("width", w);
			canvas.setAttribute("height", h);
			document.body.appendChild(canvas);
			var context = canvas.getContext("2d");
			var initializeContext = function(){
				context.strokeStyle = '#000';
				context.fillStyle = '#000';
			};
			var draggerFactory = (function(){
				var dispatchDragStart = function(x,y){
					var event = new CustomEvent('positiondragstart',{'detail':{x:x,y:y}});
					canvas.dispatchEvent(event);
				};
				var dispatchDragMove = function(origX, origY, toX, toY){
					var event = new CustomEvent('positiondragmove',{
						'detail':{
							origX:origX,
							origY:origY,
							toX:toX,
							toY:toY
						}
					});
					canvas.dispatchEvent(event);
				};
				var dispatchDragEnd = function(){
					var event = new CustomEvent('positiondragend');
					canvas.dispatchEvent(event);
				};
				var make = function(startMouseX, startMouseY){
					dispatchDragStart(startMouseX, startMouseY);
					var dragTo = function(mouseX, mouseY){
						dispatchDragMove(startMouseX, startMouseY, mouseX, mouseY);
					};
					return {
						dragTo:dragTo,
						end:dispatchDragEnd
					};
				};
				return {
					make:make
				};
			})();
			initializeContext();
			canvas.addEventListener('click',function(e){
				if(dragHappened){
					dragHappened = false;
					return true;
				}
				if(e.shiftKey){
					var loc = mousePositionToPositionLocation(e.clientX, e.clientY);
					selection.select(loc.x, loc.y);
					drawAll();
					return;
				}
				menu.hide();
				if(selection.isPresent()){
					selection.clear();
				}else{
					var p = mousePositionToPosition(e.clientX, e.clientY);
					
					if(p.isOccupied()){
						p.vacate();
					}else{
						p.occupy();
					}
				}
				drawAll();
			});
			canvas.addEventListener('touchstart',function(e){
				var list = e.touches;
				if(list.length == 1){
					var touch = list.item(0);
					console.log("making dragger");
					dragger = draggerFactory.make(touch.clientX, touch.clientY);
				}
			});
			canvas.addEventListener('touchend',function(e){
				var list = e.touches;
				if(list.length == 0){
					dragger.end();
					dragger = null;
				}
			});
			canvas.addEventListener('touchmove',function(e){
				var list = e.touches;
				if(list.length == 1){
					var touch = list.item(0);
					dragger.dragTo(touch.clientX, touch.clientY);
					dragHappened = true;
				}
			});
			canvas.addEventListener('mousedown',function(e){
				dragger = draggerFactory.make(e.clientX, e.clientY);
			});
			canvas.addEventListener('mousemove',function(e){
				if(dragger && (e.movementX != 0 || e.movementY != 0) ){
					dragger.dragTo(e.clientX, e.clientY);
					dragHappened = true;
				}
				return true;
			});
			canvas.addEventListener('mouseup',function(){
				dragger.end();
				dragger = null;
			});
			canvas.addEventListener('contextmenu',function(e){
				e.preventDefault();
				menu.show(e.clientX, e.clientY);
				return false;
			});
			return {
				context:context,
				clear:function(){canvas.width = w;initializeContext();},
				addEventListener:function(name, handler){canvas.addEventListener(name, handler);}
			};
		})(),
		menu = (function(){
			var currentX, currentY;
			var div = document.createElement("div");
			div.setAttribute("class","menu");
			document.body.appendChild(div);
			var addOption = function(text, f){
				var option = document.createElement('div');
				option.setAttribute("class","option");
				option.appendChild(document.createTextNode(text));
				option.addEventListener('click', function(){
					hide();
					f(currentX, currentY);
				});
				div.appendChild(option);
				return function(){div.removeChild(option);}
			};
			var show = function(x,y){
				var loc = mousePositionToPositionLocation(x,y);
				currentX = loc.x;
				currentY = loc.y;
				div.style.display = "initial";
				div.style.left = x + "px";
				div.style.top = y + "px";
			};
			var hide = function(){div.style.display = "none"};
			return {
				addOption:addOption,
				show:show,
				hide:hide
			}
		})(),
		selection = (function(){
			var present = false, removeMenuOption = null, minX, minY, maxX, maxY;
			var direction = {UP:0,DOWN:1,LEFT:2,RIGHT:3};
			var getPositions = function(){
				return position.getAllInBox({
							minX:minX,
							maxX:maxX,
							minY:minY,
							maxY:maxY
						});
			};
			var copyPositions = function(positions){
				clipboard.copy(positions.map(function(p){return {
						x: p.x - minX,
						y: p.y - minY
					};}), true);
			};
			var addMenuOptions = function(){
				var remove = [];
				remove.push(menu.addOption('make RLE',
					function(){
						alert(makeRLE(getPositions()));
					}));
				remove.push(menu.addOption('copy',function(x,y){
					var positions = getPositions();
					copyPositions(positions);
					clear();
					drawAll();
				}));
				remove.push(menu.addOption('cut',function(){
					var positions = getPositions();
					copyPositions(positions);
					positions.map(function(p){p.vacate();});
					clear();
					drawAll();
				}));
				remove.push(menu.addOption('alive', function(){
					for(var x=minX;x<=maxX;x++){
						for(var y=minY;y<=maxY;y++){
							position(x,y).occupy();
						}
					}
					clear();
					drawAll();
				}));
				remove.push(menu.addOption('dead', function(){
					getPositions().map(function(p){p.vacate();});
					clear();
					drawAll();
				}));
				remove.push(menu.addOption('random', function(){
					for(var x=minX;x<=maxX;x++){
						for(var y=minY;y<=maxY;y++){
							if(Math.random()<0.5){
								position(x,y).occupy();
							}
						}
					}
					clear();
					drawAll();
				}));
				return function(){
					remove.map(function(f){f();});
					remove = [];
				};
			};
			var select = function(x,y){
				if(!present){
					minX = maxX = x;
					minY = maxY = y;
					present = true;
				}else{
					if(x > minX){
						maxX = x;
					}else{
						maxX = minX;
						minX = x;
					}
					if(y > minY){
						maxY = y;
					}else{
						maxY = minY;
						minY = y;
					}
				}
				!removeMenuOption && (removeMenuOption = addMenuOptions());
			};
			var draw = function(){
				if(!present){return;}
				context.save();
				context.strokeStyle = '#00f';
				context.lineWidth = 2;
				var minLoc = positionToMousePosition({x:minX,y:minY});
				var maxLoc = positionToMousePosition({x:maxX + 1,y:maxY + 1});
				context.strokeRect(minLoc.x, minLoc.y, maxLoc.x - minLoc.x, maxLoc.y - minLoc.y);
				context.restore();
			};
			var clear = function(){
				present = false;
				removeMenuOption && removeMenuOption();
				removeMenuOption = null;
			};
			var moveInDirection = function(dir){
				if(!present){
					return;
				}
				var selectedPositions = getPositions();
				selectedPositions.map(function(p){
					p.vacate();
				});
				selectedPositions.map(function(p){
					if(dir == direction.UP){
						position(p.x,p.y-1).occupy();
					}else if(dir == direction.DOWN){
						position(p.x,p.y+1).occupy();
					}else if(dir == direction.LEFT){
						position(p.x-1,p.y).occupy();
					}else if(dir == direction.RIGHT){
						position(p.x+1,p.y).occupy();
					}
				});
				if(dir == direction.UP){
					minY -= 1;
					maxY -=1;
				}
				if(dir == direction.DOWN){
					minY += 1;
					maxY +=1;
				}
				if(dir == direction.LEFT){
					minX -= 1;
					maxX -=1;
				}
				if(dir == direction.RIGHT){
					minX += 1;
					maxX +=1;
				}
			};
			return {
				select:select,
				draw:draw,
				clear:clear,
				moveLeft:function(){
					moveInDirection(direction.LEFT);
				},
				moveRight:function(){
					moveInDirection(direction.RIGHT);
				},
				moveUp:function(){
					moveInDirection(direction.UP);
				},
				moveDown:function(){
					moveInDirection(direction.DOWN);
				},
				isPresent:function(){return present;},
				containsMousePosition:function(mouseX, mouseY){
					var pos = mousePositionToPositionLocation(mouseX, mouseY);
					return pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY;
				}
			};
		})(),
		input = (function(){
			var open = false;
			var div = document.createElement('div');
			div.setAttribute("class","input");
			var text = document.createElement('textarea');
			var button = document.createElement('input');
			button.setAttribute('type','button');
			button.setAttribute('value','OK');
			div.appendChild(text);
			div.appendChild(button);
			var show = function(initialText){
				open = true;
				div.style.display = 'initial';
				if(initialText){
					text.value = initialText;
				}
			};
			var hide = function(){
				open = false;
				div.style.display = 'none';
			};
			var handler = function(v){};
			document.body.appendChild(div);
			button.addEventListener('click',function(){
				handler(text.value);
			});
			hide();
			var f = function(resultHandler, initialText){
				show(initialText);
				handler = function(v){
					hide();
					resultHandler(v);
				};
			};
			f.isOpen = function(){return open;};
			return f;
		})(),
		alert = function(text){
			input(function(){
				clear();
				drawAll();
			},text);
		},
		clipboard = (function(){
			var relativePositions, removeMenuOption;
			var paste = function(x, y){
				relativePositions.map(function(p){
					position(x + p.x,y + p.y).occupy();
				});
				drawAll();
			};
			var copy = function(_relativePositions, makeSnapshot){
				relativePositions = _relativePositions;
				!removeMenuOption && (removeMenuOption = menu.addOption('paste', paste));
				if(makeSnapshot){
					snapshots.add(_relativePositions);
				}
			};
			
			return {copy:copy};
		})(),
		speedRange = (function(){
			var getLength = interpolation(1000,100,0.05);
			var range = document.createElement('input');
			range.setAttribute('type','range');
			range.setAttribute('class','speed-range');
			document.body.appendChild(range);
			range.addEventListener('input',function(){
				var newLength = getLength(range.value);
				console.log(newLength);
				intervalLength = Math.max(1, newLength); 
			});
		})(),
		context = c.context,
		clear = c.clear,
		fillRect = function(screenX, screenY){
			context.fillRect(screenX, screenY, size, size);
		},
		drawVerticalLine = function(x){
			context.beginPath();
			context.moveTo(x,0);
			context.lineTo(x,h);
			context.stroke();
		},
		mousePositionToPositionLocation = function(mX,mY){
			return {
				x:Math.floor(mX / size) - xShift,
				y:Math.floor(mY / size) - yShift
			};
		},
		mousePositionToPosition = function(mX, mY){
			var positionLocation = mousePositionToPositionLocation(mX,mY);
			return position(positionLocation.x,positionLocation.y);
		},
		positionToMousePosition = function(p){
			return {
				x:(p.x + xShift) * size,
				y:(p.y + yShift) * size
			};
		},
		position = quadTreePositionFactory(),
		snapshots = (function(){
			var snapshotWidth = 150, snapshotHeight = 150;
			var makeSnapshot = function(positions, forget){
				var setPositions = function(){
					minX = Math.min.apply(null, positions.map(function(p){return p.x;}));
					maxX = Math.max.apply(null, positions.map(function(p){return p.x;}));
					minY = Math.min.apply(null, positions.map(function(p){return p.y;}));
					maxY = Math.max.apply(null, positions.map(function(p){return p.y;}));
					positions = positions.map(function(p){
						return {x:p.x-minX,y:p.y-minY};
					});
				};
				var minX, maxX, minY, maxY, origMinX, origMinY;
				setPositions();
				origMinX = minX;
				origMinY = minY;
				var draw = function(canvas){
					var ctx = canvas.getContext("2d");
					ctx.fillStyle = '#000';
					var cellSize = Math.min(snapshotWidth / (maxX - minX + 1), snapshotHeight / (maxY - minY + 1));
					positions.map(function(p){
						ctx.fillRect(p.x * cellSize, p.y * cellSize, cellSize, cellSize);
					});
				};
				var flipHorizontal = function(){
					positions = positions.map(function(p){
						return {x:-p.x,y:p.y};
					});
					setPositions();
				};
				var flipVertical = function(){
					positions = positions.map(function(p){
						return {x:p.x,y:-p.y};
					});
					setPositions();
				};
				var restore = function(){
					position.vacateAll();
					stepCount = 0;
					setCounter();
					positions.map(function(p){
						position(origMinX + p.x,origMinY + p.y).occupy();
					});
					drawAll();
				};
				var copyToClipboard = function(){
					clipboard.copy(positions);
				};
				return {
					draw:draw,
					restore:restore,
					forget:forget,
					flipHorizontal:flipHorizontal,
					flipVertical:flipVertical,
					copyToClipboard:copyToClipboard
				};
			};
			var container = document.createElement('div');
			container.setAttribute('class','snapshots');
			document.body.appendChild(container);
			var addSnapshotOption = function(layover, name, toDo){
				var option = document.createElement('div');
				option.setAttribute('class','snapshot-option');
				option.appendChild(document.createTextNode(name));
				option.addEventListener('click',toDo);
				layover.appendChild(option);
			};
			var add = function(positions){
				var s = document.createElement('div');
				s.setAttribute('class','snapshot');
				container.appendChild(s);
				var canvas = document.createElement('canvas');
				canvas.setAttribute('width',snapshotWidth);
				canvas.setAttribute('height',snapshotHeight);
				s.appendChild(canvas);
				var newSnapshot = makeSnapshot(positions, function(){
					container.removeChild(s);
				});
				
				newSnapshot.draw(canvas);
				var layover = document.createElement('div');
				layover.setAttribute('class','snapshot-layover');
				s.appendChild(layover);
				addSnapshotOption(layover, 'restore',function(){
					newSnapshot.restore();
				});
				addSnapshotOption(layover, 'copy',function(){
					newSnapshot.copyToClipboard();
				});
				addSnapshotOption(layover, 'delete',function(){
					newSnapshot.forget();
				});
				addSnapshotOption(layover, 'RLE',function(){
					alert(makeRLE(positions));
				});
				addSnapshotOption(layover, 'flip h.',function(){
					newSnapshot.flipHorizontal();
					canvas.width = snapshotWidth;
					newSnapshot.draw(canvas);
				});
				addSnapshotOption(layover, 'flip v.',function(){
					newSnapshot.flipVertical();
					canvas.width = snapshotWidth;
					newSnapshot.draw(canvas);
				});
			};
			return {
				add:add
			};
		})(),
		drawHorizontalLine = function(y){
			context.beginPath();
			context.moveTo(0,y);
			context.lineTo(w,y);
			context.stroke();
		},
		stepCount = 0,
		timeCount = 0,
		doStep = function(stop, done){
			try{
				var diagnosis = position.getDiagnosis();
				var positionsToVacate = diagnosis.positionsToVacate;
				var positionsToOccupy = diagnosis.positionsToOccupy;
				if(positionsToVacate.length == 0 && positionsToOccupy.length == 0){
					stop && stop();
				}
				for(var i=0;i<positionsToVacate.length;i++){
					positionsToVacate[i].vacate();
				}
				positionsToOccupy.map(function(p){position(p.x,p.y).occupy();});
				stepCount++;
				done && done();
			}catch(e){
				stop && stop();
				throw e;

			}
		},
		going = false,
		setCounterInterval,
		setCounter = (function(){
			var a = document.createElement('a');
			a.setAttribute('class','step-count');
			document.body.appendChild(a);
			return function(){
				a.innerHTML = stepCount;
			};
		})(),
		stop = function(){
			going = false;
			var timeDiff = +new Date() - timeCount;
			console.log("time diff:", timeDiff);
			window.clearInterval(setCounterInterval);
			setCounter();
		},
		intervalLength = 75,
		go = function(onStop){
			var sstop = function(){
				stop();
				onStop && onStop();
			};
			going = true;
			timeCount = +new Date();
			var afterStep = function(){
				drawAll();
				if(going){
					window.setTimeout(function(){
						doStep(sstop, afterStep);
					},intervalLength);
				}
			};
			afterStep();
			setCounterInterval = window.setInterval(setCounter, 250);
		},
		parseRLEBody = function(body, occupy){
			var parts = body.replace(/\s*/g,"").match(/\d*[bo\$]/g);
			var x = 0, y = 0;
			parts.map(function(p){
				var match = p.match(/^(\d*)([bo\$])$/);
				var number = match[1] ? parseInt(match[1]) : 1;
				for(var i=0;i<number;i++){
					if(match[2] == "$"){
						x = 0;
						y++;
					}else{
						if(match[2] == "o"){
							occupy(x,y);
						}
						x++;
					} 
				}
			});
		},
		makeRLE = function(positions){
			var lines = [];
			var getLineForY = function(y){
				var result = null;
				for(var i=0;i<lines.length;i++){
					if(lines[i].y == y){
						result = lines[i];
					}
				}
				return result;
			};
			var findLineForPosition = function(p){
				var result = getLineForY(p.y);
				if(!result){
					result = {y:p.y,positions:[]};
					lines.push(result);
				}
				return result;
			};
			positions.map(function(p){
				findLineForPosition(p).positions.push(p.x);
			});
			lines.sort(function(l1,l2){return l1.y - l2.y;});
			var ys = lines.map(function(l){return l.y;});
			var minY = Math.min.apply(null, ys);
			var maxY = Math.max.apply(null, ys);
			var lineMinX = function(l){return Math.min.apply(null, l.positions);};
			var lineMaxX = function(l){return Math.max.apply(null, l.positions);};
			var minX = Math.min.apply(null, lines.map(lineMinX));
			var maxX = Math.max.apply(null, lines.map(lineMaxX));
			var result = (function(){
				var kind = {ALIVE:0,DEAD:1,NEWLINE:2};
				var symbol = [];
				symbol[kind.ALIVE] = "o";
				symbol[kind.DEAD] = "b";
				symbol[kind.NEWLINE] = "$";
				var currentKind = -1;
				var all = [];
				var latest = null;
				var pushKind = function(k){
					if(k != currentKind){
						latest = {kind:k,count:0};
						all.push(latest);
					}
					currentKind = k;
					latest.count++;
				};
				var toString = function(){
					return all.map(function(k){return ""+(k.count > 1 ? k.count : "")+symbol[k.kind];}).join("");
				};
				return {
					alive:function(){pushKind(kind.ALIVE);},
					dead:function(){pushKind(kind.DEAD);},
					newLine:function(){pushKind(kind.NEWLINE);},
					toString:toString
				};
			})();

			for(var y=minY;y<=maxY;y++){
				var line = getLineForY(y);
				if(line){
					for(var x=minX;x<=maxX;x++){
						if(line.positions.indexOf(x) > -1){
							result.alive();
						}else{
							result.dead();
						}
					}
				}
				result.newLine();
			}
			return result.toString();
		},
		readHash = function(){
			var hash = window.location.hash;
			if(!hash){
				return;
			}
			parseRLEBody(hash.substr(1), function(x,y){
				position(x,y).occupy()
			});
		},
		drawAll = function(){
			clear();
			context.save();
			context.strokeStyle = '#ddd';
			context.strokeWidth = 0.2;
			for(var i = 0;i<nx;i++){
				drawVerticalLine(i * size);
			}
			for(var i = 0;i<ny;i++){
				drawHorizontalLine(i * size);
			}
			context.restore();
			selection.draw();
			position.draw(function(p){
				var mousePosition = positionToMousePosition(p);
				fillRect(mousePosition.x,mousePosition.y);
			});
		};
	c.addEventListener('positiondragstart',function(e){
		if(selection.isPresent() && selection.containsMousePosition(e.detail.x, e.detail.y)){

		}else{
			currentDrag = makeDrag();
		}
	});
	c.addEventListener('positiondragmove',function(e){
		if(currentDrag){
			currentDrag.drag(e.detail.toX - e.detail.origX, e.detail.toY - e.detail.origY);
		}
	});
	c.addEventListener('positiondragend',function(){
		currentDrag = null;
	});
	menu.addOption('parse RLE',function(x,y){
		input(function(v){
			if(!v){return;}
			position.vacateAll();
			parseRLEBody(v, function(xx,yy){position(xx+x,yy+y).occupy();});
			drawAll();
		});
	});
	input(function(){},"Click on a cell to bring it to life. Hit the space bar to get things moving, or to pause them if they already are. Adjust the slider to make them move faster or slower. Shift-click on a cell to make a selection, and then right-click on the selection to find some options.");
	setSize(15);
	readHash();
	drawAll();
	setCounter();
	window.health = function(){
		var all = position.countAll();
		var alive = position.countAlive();
		var treeSize = position.getCurrentTreeSize();
		return {
			all:all,
			alive:alive,
			ratio:all/alive,
			treeSize: treeSize
		};
	};

	var shortcuts = [
		{
			key:"s",
			action:function(){
				doStep();
				drawAll();
				setCounter();
			}
		},{
			key: "r",
			action:function(){
				snapshots.add(position.getAllAlive());
			}
		},{
			key:"c",
			action:function(){
				position.vacateAll();
				stepCount = 0;
				setCounter();
				drawAll();
			}
		},{
			key:" ",
			action:function(){
				if(going){
					stop();
				}else{
					go();
				}
			}
		}
	];
	window.addEventListener('keydown',function(e){
		shortcuts.map(function(s){
			if(e.key == s.key){
				s.action();
			}
		});
	});
	window.addEventListener('wheel',function(e){
		zoom(Math.pow(2, -e.deltaY / 200), e.clientX, e.clientY);
	});
})();
</script>
</html>
<html>
<head>
	<title>Conway's Game of Life</title>
	<LINK href="font-awesome.min.css" rel="stylesheet" type="text/css" />
	<LINK href="gameoflife.css" rel="stylesheet" type="text/css" />
	
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
</head>
<body style="padding:0px;margin:0px"></body>
<script src="quadtree.js"></script>
<script src="tree/hashmap.js"></script>
<script src="tree/hashmapprovider.js"></script>
<script src="tree/treenodebase.js"></script>
<script src="tree/treenode.js"></script>
<script src="tree/canonicaltreenode.js"></script>
<script src="tree/memoizedtreenode.js"></script>
<script src="tree/hashlifemaker.js"></script>
<script>
(function(){
	var interpolation = function(y0, x1, c){
		var a = y0 / (1 - Math.exp(-c*x1)), b = y0 - a;
		return function(x){
			return a * Math.exp(-c*x) + b;
		};
	};
	var addClass = function(el, className){
		var oldName = el.getAttribute('class') || "";
		var oldClassNames = oldName.match(/[^\s]+/g);
		oldClassNames = oldClassNames || [];
		el.setAttribute('class', oldClassNames.concat([className]).join(" "));
	};
	var removeClass = function(el, className){
		var oldName = el.getAttribute('class') || "";
		var oldClassNames = oldName.match(/[^\s]+/g);
		oldClassNames = oldClassNames || [];
		el.setAttribute('class', oldClassNames.filter(function(n){return n != className;}).join(" "));
	};
	var w = document.body.offsetWidth,
		h = document.body.offsetHeight,
		size, nx, ny,
		setSize = function(s){
			size = s;
			nx = Math.ceil(w / size);
			ny = Math.ceil(h / size);
		},
		zoom = function(factor, centerX, centerY){
			clear();
			var pCenter = mousePositionToPositionLocation(centerX, centerY);
			var newSize = size * factor;
			if(newSize != size){
				setSize(newSize);
				setXShift(centerX/size - pCenter.x);
				setYShift(centerY/size - pCenter.y);
			}
		},
		xShift = 0,
		yShift = 0,
		xShiftOffset = 0,
		yShiftOffset = 0,
		getOffset = function(v){
			if(v >= 0){
				return v  - Math.floor(v);
			}
			return 1 - getOffset(-v);
		},
		setXShift = function(v){
			xShift = v;
			xShiftOffset = getOffset(v);
		},
		setYShift = function(v){
			yShift = v;
			yShiftOffset = getOffset(v);
		},
		currentDrag = null,
		makeDrag = function(startMouseX, startMouseY){
			var origXShift, origYShift, currentMouseX, currentMouseY, origSize;
			var resetTo = function(x,y){
				origXShift = xShift;
				origYShift = yShift;
				origSize = size;
				currentMouseX = x;
				currentMouseY = y;
				startMouseX = x;
				startMouseY = y;
			};
			resetTo(startMouseX, startMouseY);
			var origR, currentR;
			var applyDrag = function(){
				setXShift(origXShift + (currentMouseX - startMouseX) / size);
				setYShift(origYShift + (currentMouseY - startMouseY) / size);
			};
			var applyZoomAndDrag = function(){
				setSize(origSize);
				applyDrag();
				zoom(currentR / origR, currentMouseX, currentMouseY);
			};
			return {
				drag:function(toX, toY){
					currentMouseX = toX;
					currentMouseY = toY;
					if(currentR == undefined){
						applyDrag();
					}else{
						applyZoomAndDrag();
					}
					drawAll();
				},
				startZoom:function(r){
					origR = r;
					currentR = r;
				},
				changeZoom:function(r){
					currentR = r;
					applyZoomAndDrag();
					drawAll();
				},
				endZoom:function(){
					origR = undefined;
					currentR = undefined;
					resetTo(currentMouseX, currentMouseY);
				}
			};
		},
		c = (function(){
			var dragger = null;
			var zoomer = null;
			var dragHappened = false;
			var canvas = document.createElement("canvas");
			canvas.setAttribute("width", w);
			canvas.setAttribute("height", h);
			document.body.appendChild(canvas);
			var context = canvas.getContext("2d");
			var initializeContext = function(){
				context.strokeStyle = '#000';
				context.fillStyle = '#000';
			};
			var draggerFactory = (function(){
				var dispatchDragStart = function(x,y){
					var event = new CustomEvent('positiondragstart',{'detail':{x:x,y:y}});
					canvas.dispatchEvent(event);
				};
				var dispatchDragMove = function(toX, toY){
					var event = new CustomEvent('positiondragmove',{
						'detail':{
							toX:toX,
							toY:toY
						}
					});
					canvas.dispatchEvent(event);
				};
				var dispatchDragEnd = function(){
					var event = new CustomEvent('positiondragend');
					canvas.dispatchEvent(event);
				};
				var dispatchStartZoom = function(r){
					var event = new CustomEvent('startzoom', {'detail':{r:r}});
					canvas.dispatchEvent(event);
				};
				var dispatchEndZoom = function(){
					var event = new CustomEvent('endzoom');
					canvas.dispatchEvent(event);
				};
				var dispatchChangeZoom = function(r){
					var event = new CustomEvent('changezoom', {'detail':{r:r}});
					canvas.dispatchEvent(event);
				};
				var make = function(startX, startY, startId){
					dispatchDragStart(startX, startY);
					var firstTouch = {x:startX,y:startY,id:startId};
					var secondTouch;
					var getDistance = function(){
						return Math.sqrt(Math.pow(firstTouch.x - secondTouch.x,2) + Math.pow(firstTouch.y - secondTouch.y,2));
					};
					var moveTo = function(x, y, id){
						if(id == undefined || id == firstTouch.id){
							dispatchDragMove(x, y);
							if(id != undefined && id == firstTouch.id){
								firstTouch.x = x;
								firstTouch.y = y;
							}
						}else if(secondTouch && id == secondTouch.id){
							secondTouch.x = x;
							secondTouch.y = y;
							dispatchChangeZoom(getDistance());
						}
					};
					var end = function(id){
						if(id == undefined || id == firstTouch.id){
							dispatchDragEnd();
						}else if(secondTouch && id == secondTouch.id){
							dispatchEndZoom();
							secondTouch = null;
						}
					};
					var add = function(x, y, id){
						if(id != firstTouch.id && !secondTouch){
							secondTouch = {x:x,y:y,id:id};
							dispatchStartZoom(getDistance());
						}
					};
					return {
						moveTo:moveTo,
						end:end,
						add:add
					};
				};
				return {
					make:make
				};
			})();
			
			initializeContext();
			var mapTouchList = function(touchList, mapper){
				for(var i=0;i<touchList.length;i++){
					mapper(touchList.item(i));
				}
			};
			canvas.addEventListener('click',function(e){
				if(dragHappened){
					dragHappened = false;
					return true;
				}
				if(e.shiftKey){
					var loc = mousePositionToPositionLocation(e.clientX, e.clientY);
					selection.select(loc.x, loc.y);
					drawAll();
					return;
				}
				if(menu.isOpen()){
					menu.hide();
					return;
				}
				if(snapshots.isShowing()){
					snapshots.hide();
					return;
				}
				if(selection.isPresent()){
					selection.clear();
				}else{
					var p = mousePositionToPositionLocation(e.clientX, e.clientY);
					
					if(position.contains(p.x,p.y)){
						position.remove(p.x,p.y);
					}else{
						position.add(p.x,p.y);
					}
				}
				drawAll();
			});
			canvas.addEventListener('touchstart',function(e){
				mapTouchList(e.changedTouches, function(touch){
					if(!dragger){
						dragger = draggerFactory.make(touch.clientX, touch.clientY, touch.identifier);
					}else{
						dragger.add(touch.clientX, touch.clientY, touch.identifier);
					}
				});
			});
			canvas.addEventListener('touchend',function(e){
				if(!dragger){return;}
				mapTouchList(e.changedTouches, function(touch){
					dragger.end(touch.identifier);
				});
				if(e.touches.length == 0){
					dragger = null;
				}
			});
			canvas.addEventListener('touchmove',function(e){
				mapTouchList(e.changedTouches,function(touch){
					dragger.moveTo(touch.clientX, touch.clientY, touch.identifier);
				});
				dragHappened = true;
			});
			canvas.addEventListener('mousedown',function(e){
				dragger = draggerFactory.make(e.clientX, e.clientY);
			});
			canvas.addEventListener('mousemove',function(e){
				if(dragger && (e.movementX != 0 || e.movementY != 0) ){
					dragger.moveTo(e.clientX, e.clientY);
					dragHappened = true;
				}
				return true;
			});
			canvas.addEventListener('mouseup',function(){
				dragger.end();
				dragger = null;
			});
			canvas.addEventListener('contextmenu',function(e){
				if(dragger){
					dragger.end();
					dragger = null;
				}
				e.preventDefault();
				menu.show(e.clientX, e.clientY);
				return false;
			});
			return {
				context:context,
				clear:function(){canvas.width = w;initializeContext();},
				addEventListener:function(name, handler){canvas.addEventListener(name, handler);}
			};
		})(),
		menu = (function(){
			var currentX, currentY,open = false;
			var div = document.createElement("div");
			div.setAttribute("class","menu");
			document.body.appendChild(div);
			var addOption = function(text, f){
				var removed = false;
				var remove = function(){
					if(!removed){
						div.removeChild(option);
						removed = true;
					}
				};
				var option = document.createElement('div');
				option.setAttribute("class","option");
				option.appendChild(document.createTextNode(text));
				option.addEventListener('click', function(){
					hide();
					f(currentX, currentY, remove);
				});
				div.appendChild(option);
				return remove;
			};
			var show = function(x,y){
				var loc = mousePositionToPositionLocation(x,y);
				currentX = loc.x;
				currentY = loc.y;
				div.style.display = "initial";
				div.style.left = x + "px";
				div.style.top = y + "px";
				open = true;
			};
			var hide = function(){
				div.style.display = "none";
				open = false;
			};
			return {
				addOption:addOption,
				show:show,
				hide:hide,
				isOpen:function(){return open;}
			}
		})(),
		selection = (function(){
			var present = false, removeMenuOption = null, removeSelectOption = null, minX, minY, maxX, maxY, dragger;
			var getMinLoc = function(){
				return positionToMousePosition({x:minX,y:minY});
			};
			var getMaxLoc = function(){
				return positionToMousePosition({x:maxX + 1,y:maxY + 1});
			};
			var makeDraggerMaker = function(mX, mY, howToDrag){
				var isClose = function(x,y){
					var d = Math.sqrt(Math.pow(mX - x, 2) + Math.pow(mY - y, 2));
					return d < 10;
				};
				var draw = function(){
					context.save();
					context.fillStyle = '#00f';
					context.beginPath();
					context.arc(mX, mY, 4, 0, 2*Math.PI);
					context.fill();
					context.restore();
				};
				var make = function(){
					var drag = function(x,y){
						var pos = mousePositionToPositionLocation(x,y);
						howToDrag(pos);
						drawAll();
					};
					return {
						drag:drag
					};
				};
				return {
					isClose:isClose,
					draw:draw,
					make:make
				};
			};
			var getDraggerMakers = function(minLoc, maxLoc){
				var result = [];
				result.push(makeDraggerMaker(
					(minLoc.x + maxLoc.x)/2,
					minLoc.y,
					function(pos){
						minY = Math.min(maxY, pos.y);
					}
				));
				result.push(makeDraggerMaker(
					minLoc.x,
					(minLoc.y + maxLoc.y) / 2,
					function(pos){
						minX = Math.min(maxX, pos.x);
					}
				));
				result.push(makeDraggerMaker(
					(minLoc.x + maxLoc.x)/2,
					maxLoc.y,
					function(pos){
						maxY = Math.max(minY, pos.y);
					}
				));
				result.push(makeDraggerMaker(
					maxLoc.x,
					(minLoc.y + maxLoc.y) / 2,
					function(pos){
						maxX = Math.max(minX, pos.x);
					}
				));
				result.push(makeDraggerMaker(
					minLoc.x,
					minLoc.y,
					function(pos){
						minX = Math.min(maxX, pos.x);
						minY = Math.min(maxY, pos.y);
					}
				));
				result.push(makeDraggerMaker(
					minLoc.x,
					maxLoc.y,
					function(pos){
						minX = Math.min(maxX, pos.x);
						maxY = Math.max(minY, pos.y);
					}
				));
				result.push(makeDraggerMaker(
					maxLoc.x,
					minLoc.y,
					function(pos){
						maxX = Math.max(minX, pos.x);
						minY = Math.min(maxY, pos.y);
					}
				));
				result.push(makeDraggerMaker(
					maxLoc.x,
					maxLoc.y,
					function(pos){
						maxX = Math.max(minX, pos.x);
						maxY = Math.max(minY, pos.y);
					}
				));
				return result;
			};
			var makeMover = function(mouseX, mouseY){
				var positions = getPositions();
				var relativePositions = positions.map(function(p){return {x:p.x - minX,y:p.y-minY};});
				var startPos = mousePositionToPositionLocation(mouseX, mouseY);
				var relativePositionX = startPos.x - minX;
				var relativePositionY = startPos.y - minY;
				var width = maxX - minX;
				var height = maxY - minY;
				var drag = function(x,y){
					var toPos = mousePositionToPositionLocation(x, y);
					minX = toPos.x - relativePositionX;
					maxX = minX + width;
					minY = toPos.y - relativePositionY;
					maxY = minY + height;
					drawAll();
					draw();
				};
				var getNewPositions = function(){
					return relativePositions.map(function(p){return {x:minX + p.x,y:minY + p.y};});
				};
				var draw = function(){
					context.save();
					context.fillStyle = 'rgba(0,0,0,0.5)';
					getNewPositions().map(function(p){
						var pos = positionToMousePosition(p);
						context.fillRect(pos.x, pos.y,size,size);
					});
				};
				var end = function(){
					positions.map(function(p){position.remove(p.x, p.y);});
					getNewPositions().map(function(p){position.add(p.x,p.y);});
					drawAll();
				};
				return {
					drag:drag,
					end:end
				};
			};
			var makeDragger = function(mouseX, mouseY){
				var draggerMakers = getDraggerMakers(getMinLoc(), getMaxLoc());
				for(var i=0;i<draggerMakers.length;i++){
					var draggerMaker = draggerMakers[i];
					if(draggerMaker.isClose(mouseX, mouseY)){
						return draggerMaker.make();
					}
				}
				if(containsMousePosition(mouseX, mouseY)){
					return makeMover(mouseX, mouseY);
				}
			};
			var direction = {UP:0,DOWN:1,LEFT:2,RIGHT:3};
			var getPositions = function(){
				return position.getAllInBox({
							minX:minX,
							maxX:maxX,
							minY:minY,
							maxY:maxY
						});
			};
			var copyPositions = function(positions){
				clipboard.copy(positions.map(function(p){return {
						x: p.x - minX,
						y: p.y - minY
					};}), true);
			};
			var addMenuOptions = function(){
				var remove = [];
				remove.push(menu.addOption('make RLE',
					function(){
						alert(makeRLE(getPositions()));
					}));
				remove.push(menu.addOption('copy',function(x,y){
					var positions = getPositions();
					copyPositions(positions);
					clear();
					drawAll();
				}));
				remove.push(menu.addOption('cut',function(){
					var positions = getPositions();
					copyPositions(positions);
					positions.map(function(p){position.remove(p.x, p.y);});
					clear();
					drawAll();
				}));
				remove.push(menu.addOption('alive', function(){
					for(var x=minX;x<=maxX;x++){
						for(var y=minY;y<=maxY;y++){
							position.add(x,y);
						}
					}
					clear();
					drawAll();
				}));
				remove.push(menu.addOption('dead', function(){
					getPositions().map(function(p){position.remove(p.x, p.y);});
					clear();
					drawAll();
				}));
				remove.push(menu.addOption('random', function(){
					for(var x=minX;x<=maxX;x++){
						for(var y=minY;y<=maxY;y++){
							if(Math.random()<0.5){
								position.add(x,y);
							}
						}
					}
					clear();
					drawAll();
				}));
				return function(){
					remove.map(function(f){f();});
					remove = [];
				};
			};
			var select = function(x,y){
				if(!present){
					minX = maxX = x;
					minY = maxY = y;
					present = true;
					removeSelectOption && removeSelectOption();
				}else{
					if(x > minX){
						maxX = x;
					}else{
						maxX = minX;
						minX = x;
					}
					if(y > minY){
						maxY = y;
					}else{
						maxY = minY;
						minY = y;
					}
				}
				!removeMenuOption && (removeMenuOption = addMenuOptions());
			};
			var draw = function(){
				if(!present){return;}
				context.save();
				context.strokeStyle = '#00f';
				context.lineWidth = 2;
				var minLoc = getMinLoc();
				var maxLoc = getMaxLoc();
				context.strokeRect(minLoc.x, minLoc.y, maxLoc.x - minLoc.x, maxLoc.y - minLoc.y);
				getDraggerMakers(minLoc, maxLoc).map(function(d){d.draw();});
				context.restore();
			};
			var clear = function(){
				present = false;
				dragger = null;
				removeMenuOption && removeMenuOption();
				removeMenuOption = null;
				addSelectingOption();
			};
			
			var addSelectingOption = function(){
				removeSelectOption = menu.addOption('select', function(x,y,remove){
					var width = Math.floor(w / (5 * size));
					var height = Math.floor(h / (5 * size));
					select(x,y);
					select(x + width, y + height);
					drawAll();
					remove();
				});
			};
			var containsMousePosition = function(mouseX, mouseY){
				var pos = mousePositionToPositionLocation(mouseX, mouseY);
				return pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY;
			};
			addSelectingOption();
			c.addEventListener('positiondragmove',function(e){
				if(dragger){
					dragger.drag(e.detail.toX, e.detail.toY);
				}
			});
			c.addEventListener('positiondragend',function(){
				dragger && dragger.end && dragger.end();
				dragger = null;
			});
			return {
				select:select,
				draw:draw,
				clear:clear,
				moveLeft:function(){
					moveInDirection(direction.LEFT);
				},
				moveRight:function(){
					moveInDirection(direction.RIGHT);
				},
				moveUp:function(){
					moveInDirection(direction.UP);
				},
				moveDown:function(){
					moveInDirection(direction.DOWN);
				},
				isPresent:function(){return present;},
				containsMousePosition:containsMousePosition,
				handleDragStart:function(mouseX, mouseY){
					dragger = makeDragger(mouseX, mouseY);
					return !!dragger;
				}
			};
		})(),
		input = (function(){
			var open = false;
			var div = document.createElement('div');
			div.setAttribute("class","input");
			var text = document.createElement('textarea');
			var button = document.createElement('input');
			button.setAttribute('type','button');
			button.setAttribute('value','OK');
			div.appendChild(text);
			div.appendChild(button);
			var show = function(initialText){
				open = true;
				div.style.display = 'initial';
				if(initialText){
					text.value = initialText;
				}
			};
			var hide = function(){
				open = false;
				div.style.display = 'none';
			};
			var handler = function(v){};
			document.body.appendChild(div);
			button.addEventListener('click',function(){
				handler(text.value);
				text.value = '';
			});
			hide();
			var f = function(resultHandler, initialText){
				show(initialText);
				handler = function(v){
					hide();
					resultHandler(v);
				};
			};
			f.isOpen = function(){return open;};
			return f;
		})(),
		alert = function(text){
			input(function(){
				clear();
				drawAll();
			},text);
		},
		clipboard = (function(){
			var relativePositions, removeMenuOption;
			var paste = function(x, y){
				relativePositions.map(function(p){
					position.add(x + p.x,y + p.y);
				});
				drawAll();
			};
			var copy = function(_relativePositions, makeSnapshot){
				relativePositions = _relativePositions;
				!removeMenuOption && (removeMenuOption = menu.addOption('paste', paste));
				if(makeSnapshot){
					snapshots.add(_relativePositions);
				}
			};
			
			return {copy:copy};
		})(),
		controls = (function(){
			var container = document.createElement('div');
			container.setAttribute('class','controls');
			document.body.appendChild(container);
			var addButton = function(className, action){
				var div = document.createElement('div');
				div.setAttribute('class','button fa '+className);
				div.addEventListener('click',function(){
					action(function(newClassName){
						if(newClassName){
							div.setAttribute('class','button fa '+newClassName);
						}
					});
				});
				container.appendChild(div);
			};
			addButton("fa-play",function(setNewClassName){
				if(going){
					stop();
					setNewClassName("fa-play");
				}else{
					go();
					setNewClassName("fa-pause");
				}
			});
			addButton("fa-eraser",function(){
				reset();
			});
			addButton("fa-step-forward",function(){
				doStep(1);
				drawAll();
				setCounter();
			});
			addButton("fa-save",function(){
				snapshots.add(position.getAllAlive());
			});
		})(),
		speedRange = (function(){
			var getLength = interpolation(1000,100,0.05);
			var range = document.createElement('input');
			range.setAttribute('type','range');
			range.setAttribute('class','speed-range');
			document.body.appendChild(range);
			range.addEventListener('input',function(){
				if(range.value > 80 && stepSize != 2){
					console.log("setting stepSize to 2");
					stepSize = 2;
				}else if(range.value <= 80 && stepSize != 1){
					console.log("setting stepSize to 1");
					stepSize = 1;
				}
				var newLength = getLength(range.value);
				intervalLength = Math.max(1, newLength); 
			});
		})(),
		setCounter = (function(){
		    var a = document.createElement('a');
		    a.setAttribute('class','step-count');
		    document.body.appendChild(a);
		    return function(){
		            a.innerHTML = stepCount;
		    };
		})(),
		context = c.context,
		clear = c.clear,
		fillRect = function(screenX, screenY){
			context.fillRect(screenX, screenY, size, size);
		},
		drawVerticalLine = function(x){
			context.beginPath();
			context.moveTo(x,0);
			context.lineTo(x,h);
			context.stroke();
		},
		mousePositionToPositionLocation = function(mX,mY){
			return {
				x:Math.floor(mX / size - xShift),
				y:Math.floor(mY / size - yShift)
			};
		},
		positionToMousePosition = function(p){
			return {
				x:(p.x + xShift) * size,
				y:(p.y + yShift) * size
			};
		},
		position = hashLifeMaker(),
		snapshots = (function(){
			var showing = false, count = 0;
			var snapshotWidth = 120, snapshotHeight = 120;
			var makeSnapshot = function(positions, forget){
				var setPositions = function(){
					minX = Math.min.apply(null, positions.map(function(p){return p.x;}));
					maxX = Math.max.apply(null, positions.map(function(p){return p.x;}));
					minY = Math.min.apply(null, positions.map(function(p){return p.y;}));
					maxY = Math.max.apply(null, positions.map(function(p){return p.y;}));
					positions = positions.map(function(p){
						return {x:p.x-minX,y:p.y-minY};
					});
				};
				var minX, maxX, minY, maxY, origMinX, origMinY;
				setPositions();
				origMinX = minX;
				origMinY = minY;
				var draw = function(canvas){
					var ctx = canvas.getContext("2d");
					ctx.fillStyle = '#fff';
					ctx.fillRect(0,0,snapshotWidth,snapshotHeight);
					ctx.fillStyle = '#000';
					var cellSize = Math.min(snapshotWidth / (maxX - minX + 1), snapshotHeight / (maxY - minY + 1));
					positions.map(function(p){
						ctx.fillRect(p.x * cellSize, p.y * cellSize, cellSize, cellSize);
					});
				};
				var flipHorizontal = function(){
					positions = positions.map(function(p){
						return {x:-p.x,y:p.y};
					});
					setPositions();
				};
				var flipVertical = function(){
					positions = positions.map(function(p){
						return {x:p.x,y:-p.y};
					});
					setPositions();
				};
				var restore = function(){
					position.vacateAll();
					stepCount = 0;
					setCounter();
					positions.map(function(p){
						position.add(origMinX + p.x,origMinY + p.y);
					});
					drawAll();
				};
				var copyToClipboard = function(){
					clipboard.copy(positions);
				};
				return {
					draw:draw,
					restore:restore,
					forget:forget,
					flipHorizontal:flipHorizontal,
					flipVertical:flipVertical,
					copyToClipboard:copyToClipboard
				};
			};
			var show = function(){
				addClass(document.body,'show-snapshots');
				showing = true;
			};
			var hide = function(){
				removeClass(document.body,'show-snapshots');
				showing = false;
			};
			var container = document.createElement('div');
			container.setAttribute('class','snapshots');
			document.body.appendChild(container);
			var addSnapshotOption = function(layover, name, toDo){
				var option = document.createElement('div');
				option.setAttribute('class','button snapshot-option fa '+name);
				option.addEventListener('click',toDo);
				layover.appendChild(option);
			};
			var add = function(positions){
				positions = positions.map(function(p){return {x:p.x,y:p.y};});
				var s = document.createElement('div');
				s.setAttribute('class','snapshot');
				var s1 = document.createElement('div');
				s1.setAttribute('class','snapshot-part');
				s.appendChild(s1);
				var s2 = document.createElement('div');
				s2.setAttribute('class','snapshot-part');
				s.appendChild(s2);
				container.appendChild(s);
				var canvas = document.createElement('canvas');
				canvas.setAttribute('width',snapshotWidth);
				canvas.setAttribute('height',snapshotHeight);
				s1.appendChild(canvas);
				var newSnapshot = makeSnapshot(positions, function(){
					container.removeChild(s);
					count--;
					if(count == 0){
						removeClass(document.body,'show-snapshots');
						removeClass(document.body,'has-snapshots');
					}
				});
				
				newSnapshot.draw(canvas);
				
				addSnapshotOption(s2, 'fa-folder-open',function(){
					newSnapshot.restore();
				});
				addSnapshotOption(s2, 'fa-copy',function(){
					newSnapshot.copyToClipboard();
				});
				addSnapshotOption(s2, 'fa-trash',function(){
					newSnapshot.forget();
				});
				addSnapshotOption(s2, 'fa-file-code-o',function(){
					alert(makeRLE(positions));
				});
				addSnapshotOption(s2, 'fa-arrows-h',function(){
					newSnapshot.flipHorizontal();
					canvas.width = snapshotWidth;
					newSnapshot.draw(canvas);
				});
				addSnapshotOption(s2, 'fa-arrows-v',function(){
					newSnapshot.flipVertical();
					canvas.width = snapshotWidth;
					newSnapshot.draw(canvas);
				});
				addClass(document.body, 'has-snapshots');
				count++;
			};
			var button = document.createElement('div');
			button.setAttribute('class','button snapshot-button fa fa-inbox');
			document.body.appendChild(button);
			button.addEventListener('click',function(){
				if(showing){
					hide();
				}else{
					show();
				}
			});
			var closeButton = document.createElement('div');
			closeButton.setAttribute('class','button snapshot-close-button fa fa-close');
			container.appendChild(closeButton);
			closeButton.addEventListener('click',hide);
			return {
				add:add,
				isShowing:function(){return showing;},
				hide:hide
			};
		})(),
		drawHorizontalLine = function(y){
			context.beginPath();
			context.moveTo(0,y);
			context.lineTo(w,y);
			context.stroke();
		},
		stepCount = 0,
		timeCount = 0,
		stepSize = 1,
		doStep = function(_stepSize, done){
			position.doStep(_stepSize);
			stepCount += _stepSize;
			done && done();
		},
		going = false,
		setCounterInterval,
		stop = function(){
			going = false;
			var timeDiff = +new Date() - timeCount;
			console.log("time diff:", timeDiff);
			window.clearInterval(setCounterInterval);
			setCounter();
		},
		intervalLength = 75,
		go = function(){
			going = true;
			timeCount = +new Date();
			var afterStep = function(){
				drawAll();
				window.setTimeout(function(){
					if(going){
						doStep(stepSize, afterStep);
					}
				},intervalLength);
			};
			afterStep();
			setCounterInterval = window.setInterval(setCounter, 250);
		},
		reset = function(){
			position.vacateAll();
			stepCount = 0;
			setCounter();
			drawAll();
		},
		parseRLEBody = function(body, occupy){
			var parts = body.replace(/\s*/g,"").match(/\d*[bo\$]/g);
			var x = 0, y = 0;
			parts.map(function(p){
				var match = p.match(/^(\d*)([bo\$])$/);
				var number = match[1] ? parseInt(match[1]) : 1;
				for(var i=0;i<number;i++){
					if(match[2] == "$"){
						x = 0;
						y++;
					}else{
						if(match[2] == "o"){
							occupy(x,y);
						}
						x++;
					} 
				}
			});
		},
		makeRLE = function(positions){
			var lines = [];
			var getLineForY = function(y){
				var result = null;
				for(var i=0;i<lines.length;i++){
					if(lines[i].y == y){
						result = lines[i];
					}
				}
				return result;
			};
			var findLineForPosition = function(p){
				var result = getLineForY(p.y);
				if(!result){
					result = {y:p.y,positions:[]};
					lines.push(result);
				}
				return result;
			};
			positions.map(function(p){
				findLineForPosition(p).positions.push(p.x);
			});
			lines.sort(function(l1,l2){return l1.y - l2.y;});
			var ys = lines.map(function(l){return l.y;});
			var minY = Math.min.apply(null, ys);
			var maxY = Math.max.apply(null, ys);
			var lineMinX = function(l){return Math.min.apply(null, l.positions);};
			var lineMaxX = function(l){return Math.max.apply(null, l.positions);};
			var minX = Math.min.apply(null, lines.map(lineMinX));
			var maxX = Math.max.apply(null, lines.map(lineMaxX));
			var result = (function(){
				var kind = {ALIVE:0,DEAD:1,NEWLINE:2};
				var symbol = [];
				symbol[kind.ALIVE] = "o";
				symbol[kind.DEAD] = "b";
				symbol[kind.NEWLINE] = "$";
				var currentKind = -1;
				var all = [];
				var latest = null;
				var pushKind = function(k){
					if(k != currentKind){
						latest = {kind:k,count:0};
						all.push(latest);
					}
					currentKind = k;
					latest.count++;
				};
				var toString = function(){
					return all.map(function(k){return ""+(k.count > 1 ? k.count : "")+symbol[k.kind];}).join("");
				};
				return {
					alive:function(){pushKind(kind.ALIVE);},
					dead:function(){pushKind(kind.DEAD);},
					newLine:function(){pushKind(kind.NEWLINE);},
					toString:toString
				};
			})();

			for(var y=minY;y<=maxY;y++){
				var line = getLineForY(y);
				if(line){
					for(var x=minX;x<=maxX;x++){
						if(line.positions.indexOf(x) > -1){
							result.alive();
						}else{
							result.dead();
						}
					}
				}
				result.newLine();
			}
			return result.toString();
		},
		readHash = function(){
			var hash = window.location.hash;
			if(!hash){
				return;
			}
			parseRLEBody(hash.substr(1), function(x,y){
				position.add(x,y);
			});
		},
		drawAll = function(){
			clear();
			context.save();
			context.strokeStyle = '#ddd';
			context.strokeWidth = 0.2;
			for(var i = 0;i<nx;i++){
				drawVerticalLine(i * size + xShiftOffset * size);
			}
			for(var i = 0;i<ny;i++){
				drawHorizontalLine(i * size + yShiftOffset * size);
			}
			context.restore();
			selection.draw();
			position.draw(function(p){
				var mousePosition = positionToMousePosition(p);
				fillRect(mousePosition.x,mousePosition.y);
			});
		};
	c.addEventListener('positiondragstart',function(e){
		if(!selection.isPresent() || !selection.handleDragStart(e.detail.x, e.detail.y)){
			currentDrag = makeDrag(e.detail.x, e.detail.y);
		}
	});
	c.addEventListener('positiondragmove',function(e){
		if(currentDrag){
			currentDrag.drag(e.detail.toX, e.detail.toY);
		}
	});
	c.addEventListener('positiondragend',function(){
		currentDrag = null;
	});
	c.addEventListener('startzoom',function(e){
		if(currentDrag){
			currentDrag.startZoom(e.detail.r);
		}
	});
	c.addEventListener('changezoom',function(e){
		if(currentDrag){
			currentDrag.changeZoom(e.detail.r);
		}
	});
	c.addEventListener('endzoom',function(e){
		if(currentDrag){
			currentDrag.endZoom();
		}
	});
	menu.addOption('parse RLE',function(x,y){
		input(function(v){
			if(!v){return;}
			position.vacateAll();
			parseRLEBody(v, function(xx,yy){position.add(xx+x,yy+y);});
			drawAll();
		});
	});
	
	input(function(){},"Click on a cell to bring it to life. Hit the space bar to get things moving, or to pause them if they already are. Adjust the slider to make them move faster or slower. Shift-click on a cell to make a selection, and then right-click on the selection to find some options.");
	setSize(15);
	readHash();
	drawAll();
	setCounter();
	window.health = function(){
		var all = position.countAll();
		var alive = position.countAlive();
		var treeSize = position.getCurrentTreeSize();
		return {
			all:all,
			alive:alive,
			ratio:all/alive,
			treeSize: treeSize
		};
	};

	var shortcuts = [
		{
			key:"s",
			action:function(){
				doStep(1);
				drawAll();
				setCounter();
			}
		},{
			key: "r",
			action:function(){
				snapshots.add(position.getAllAlive());
			}
		},{
			key:"c",
			action:reset
		},{
			key:" ",
			action:function(){
				if(going){
					stop();
				}else{
					go();
				}
			}
		}
	];
	window.addEventListener('keydown',function(e){
		shortcuts.map(function(s){
			if(e.key == s.key){
				s.action();
			}
		});
	});
	window.addEventListener('wheel',function(e){
		zoom(Math.pow(2, -e.deltaY / 200), e.clientX, e.clientY);
		drawAll();
	});
})();
</script>
</html>